---
title: 'W271 Lab 2: CO2 Present'
geometry: margin=1in
output:
  github_document: default
---

```{r load packages, echo = FALSE, message = FALSE, warning=FALSE}
library(tidyverse)
library(tsibble)
library(latex2exp)
theme_set(theme_minimal())
knitr::opts_chunk$set(dpi = 1000)
knitr::opts_chunk$set(tidy.opts = list(width_cutoff = 100), tidy = TRUE)
knitr::opts_chunk$set(message = FALSE)

# additional packages
library(dplyr)
library(Hmisc)
library(patchwork)
library(forecast)
library(stargazer)
library(gridExtra)
library(magrittr)

## To laod All data sets in the book "Forecasting: principles and practice"
# by Rob J Hyndman and George Athanasopoulos
# install.packages("fpp3")
# install.packages("fpp2")

library(fpp3)
library(fpp2)
```

## (3 points) Task 0b: Introduction 
In our 1997 report, we used the linear models and the ARIMA model to forecast the $CO_2$  level through 2020 and beyond.  We noted the $CO_2$  level increased from 360 ppmv in 1997 to 420 ppmv as of February 2023, which was at the higher end of our forecast interval (385-424 ppmv) at the 95% confidence level.  We plan to compare our 1997 forecast to the monthly actual levels to evaluate the model performance.  We will leverage the learnings to enhance our model performance. 

While this may not affect our analysis, we noticed that due to the eruption of the Mauna Loa Volcano, measurements from Mauna Loa Observatory were suspended as of Nov. 29, 2022. Observations starting in December 2022 are from a site at the Maunakea Observatories, approximately 21 miles north of the Mauna Loa Observatory. We believe this should not pose a significant impact on the data generation process though.


## (3 points) Task 1b: Create a modern data pipeline for Mona Loa CO2 data.

We sourced the weekly and monthly data set from the United States' National Oceanic and Atmospheric Administration data page [[here](https://gml.noaa.gov/ccgg/trends/data.html)]. We noted 18 observations with -999.99 value (missing values) in the weekly dataset. We replaced the 18 invalid weekly values with their corresponding monthâ€™s value in the monthly data set.  Then we generated two clean time series data sets from May 1974 to March 2023: co2_present (weekly frequency) and co2_present_month (monthly frequency).

Similar to our 1997 observations, we continued to see an increasing $CO_2$ level and seasonal variability (see charts in Figure \@ref(fig:CO2-ETSDA) below), however, the trend line steepened after 2005.  The annual growth rates are mostly in the range of 0 to 1% (slightly wider than the 1997 range of 0-0.75%). The  $CO_2$ Decomposition graph continued to show an upward trend, strong seasonality, and the irregular effect.

We noted that the peak $CO_2$ month is April (instead of May in 1997 report) and the lowest month is September (instead of October), The difference between the peak and lowest month is similar ($`r max_min_diff`$ ppmv)    max_min_diff <- max(box$stats[3, ]) - min(box$stats[3, ])

```{r data-load-pipeline-from-website, echo=FALSE, message=FALSE, warning=FALSE}
co2_present_raw <- read.csv("https://gml.noaa.gov/webdata/ccgg/trends/co2/co2_weekly_mlo.csv",
  sep = ",",
  skip = 51
)
head(co2_present_raw)
```

```{r create-time-component, echo=FALSE, message=FALSE, warning=FALSE}
co2_present_raw <- co2_present_raw %>%
  select(year, month, day, average) %>%
  mutate(time_index = yearweek(
    paste(
      year,
      month,
      day,
      sep = "-"
    )
  ))

co2_present_raw %>%
  ggplot(aes(y = average, x = time_index)) +
  geom_line()
```

```{r eda: fill-the-missing-weekly-data-from-monthly, echo=FALSE, message=FALSE, warning=FALSE}
co2_present_month <- read.csv(
  "https://gml.noaa.gov/webdata/ccgg/trends/co2/co2_mm_mlo.csv",
  sep = ",", skip = 56
)

# remove outliers and replace with monthly average
co2_present_raw <- co2_present_raw %>%
  left_join(y = co2_present_month, by = c("year", "month")) %>%
  within(., value <- ifelse(average.x == -999.99, average.y, average.x))

co2_present <- co2_present_raw %>%
  dplyr::select(time_index, year, month, day, value) %>%
  tsibble::as_tsibble(index = time_index)

# basic information about the data
# head(co2_present)
# print(sum(is.na(co2_present)))
# print(start(co2_present$time_index))
# print(end(co2_present$time_index))
```

```{r time-plot, include=FALSE, echo=FALSE, message=FALSE, warning=FALSE}
co2_present %>%
  ggplot() +
  aes(x = time_index, y = value) +
  geom_line(color = "steelblue") +
  labs(
    title = TeX(r'(Present Date Monthly Mean $CO_2$)'),
    subtitle = 'The "Keeling Curve"',
    x = "Month and Year",
    y = TeX(r'($CO_2$ parts per million)')
  )
```

```{r CO2-ETSDA, echo = FALSE, warning=FALSE, message=FALSE, fig.align='center', out.width="65%", fig.cap="Atmospheric CO2 Level Time Series Overview"}
co2_enhanced <- co2_present %>%
  mutate(
    annual_growth = (value - lag(value, n = 52)) / lag(value, n = 52) * 100,
    log_value = log(value)
  )

# Use additive method in STL decomposition
dcmp_add <- co2_enhanced %>%
  model(stl = STL(value))

# plot of time series
p1 <- components(dcmp_add) %>%
  as_tsibble() %>%
  autoplot(value, colour = "gray") +
  geom_line(aes(y = trend), colour = "#D55E00") +
  labs(
    y = TeX(r"($CO_2$ Annualized Growth Rate)"),
    x = "Month and Year",
    title = "Monthly Mean CO2"
  ) +
  theme(plot.title = element_text(size = 10))

# plot the annualized growth rate
p2 <- co2_enhanced %>%
  ggplot() +
  aes(x = time_index, y = annual_growth) +
  geom_line(color = "steelblue") +
  labs(
    title = TeX(r'(Annualized Growth $CO_2$)'),
    subtitle = 'The "Keeling Curve"',
    x = "Month and Year",
    y = TeX(r'($CO_2$ Annualized Growth Rate)')
  ) +
  theme(plot.title = element_text(size = 10))

# plot the histogram
p3 <- co2_enhanced %>%
  ggplot(aes(x = value)) +
  geom_histogram(binwidth = 1) +
  labs(title = TeX(r'(Histogram Monthly Mean $CO_2$)'), col = " blue") +
  xlab("Monthly Mean") +
  theme(plot.title = element_text(size = 10))
# scale_x_continuous(limits = c(0, 16), breaks = seq(1,16,2))

# plot the components
p4 <- components(dcmp_add) %>%
  autoplot() + theme(plot.title = element_text(size = 10))

(p1 | p2) / (p3 | p4)
```
```{r generate-monthly-indexed-summary, echo=FALSE, message=FALSE, warning=FALSE}
co2_present_monthly <- co2_present %>%
  index_by(month_index = ~ yearmonth(.)) %>%
  summarise(
    value = mean(value)
  ) %>%
  tsibble::as_tsibble(index = month_index) %>%
  drop_na()
```

```{r boxplot, echo=FALSE, include=FALSE, message=FALSE, warning=FALSE, fig.align='center', out.width="65%", fig.cap="Seasonality CO2 Level Monthly Distribution"}
# box plot
co2_present_ts <- co2_present_monthly %>%
  select(month_index, value) %>%
  as.ts()
# could use geom_boxplot() in ggplot2
box <- boxplot(co2_present_ts ~ cycle(co2_present_ts, xlab = "Month", ylab = "CO2 (ppm)", main = "Monthly Mean CO2"))
```


## (1 point) Task 2b: Compare linear model forecasts against realized CO2
In our 1997 report, we developed the two linear models (one model using time as the single variable, and the other model using the third polynomial degree of trend, and seasonality), and forecasted the $CO_2$ level through 2020 and beyond. We compared the forecast results to our actuals through the present (February 2023).  Both models under-forecasted the $CO_2$ level and performed poorly. The linear model outperformed the polynomial model over the longer term, which is expected based on how third degree polynomials behave. See figure (one with ARIMA).

The linear model with time variable projected a straight trend line (without any seasonal effect) and forecasted $CO_2$ to reach 395 ppmv in February 2023, while the actual level was 420 ppmv. The polynomial model captured the seasonal effect and projected increasing levels until the mid-2021 and then flattened and shifted downward.  The polynomial model forecasted 384 ppmv for February 2023. 

```{r, original-linear-model, echo=FALSE, message=FALSE, warning=FALSE, include=FALSE}
# create a time series for the prediction period
co2_cutoff <- yearmonth(lubridate::make_date(1998, 1))
prediction_ts <- co2_present_monthly %>%
  filter(month_index >= co2_cutoff)
h <- length(prediction_ts$month_index)

# original linear model with forecast
mod.poly <- tslm(co2 ~ poly(trend, 3) + season)
poly_forecast <- forecast::forecast(mod.poly, level = c(95), h = h)

mod.lm <- tslm(co2 ~ trend)
lm_forecast <- forecast::forecast(mod.lm, level = c(95), h = h)

prediction_ts <- prediction_ts %>%
  add_column(
    poly_forecast = poly_forecast$mean
  ) %>%
  add_column(
    lm_forecast = lm_forecast$mean
  )

# visualize the forecast vs the actual
prediction_ts %>%
  ggplot() +
  aes(x = month_index) +
  geom_line(aes(x = month_index, y = value, color = "Actual")) +
  geom_line(aes(x = month_index, y = lm_forecast, color = "Linear")) +
  geom_line(aes(x = month_index, y = poly_forecast, color = "Polynomial")) +
  labs(
    x = "Month and Year",
    y = "CO2 Level (ppmv)",
    title = "Model Prediction vs Actual CO2 Level"
  )
```

## (1 point) Task 3b: Compare ARIMA models forecasts against realized CO2  
In our 1997 report, we also fitted an ARIMA model (ARIMA(0,1,1)(1,1,2)[12]). This model captured the seasonal effect and projected well until 2005.  The model under-forecasted $CO_2$ levels after 2005. The ARIMA model forecasted 405 ppmv for 2/2023 vs. the actual level of 420 ppmv (figure). The ARIMA model performs much better than the two linear models.

```{r, original-arima-model, echo=FALSE, message=FALSE, warning=FALSE}
# original arima model with forecast
mod.arima <- arima(co2, order = c(0, 1, 1), seasonal = list(order = c(1, 1, 2), period = 12))
arima_forecast <- forecast::forecast(mod.arima, level = c(95), h = h)

prediction_ts <- prediction_ts %>% add_column(
  arima_forecast = arima_forecast$mean
)

# visualize the forecast vs the actual
prediction_ts %>%
  ggplot() +
  geom_line(aes(x = month_index, y = value, color = "Actual")) +
  geom_line(aes(x = month_index, y = lm_forecast, color = "Linear")) +
  geom_line(aes(x = month_index, y = poly_forecast, color = "Polynomial")) +
  geom_line(aes(x = month_index, y = arima_forecast, color = "ARIMA")) +
  labs(
    x = "Month and Year",
    y = "CO2 Level (ppmv)",
    title = "Model Prediction vs Actual CO2 Level"
  )
```

## (3 points) Task 4b: Evaluate the performance of 1997 linear and ARIMA models 
In our 1997 report, our ARIMA model projected about the first time that CO2 would cross 420 ppm in May 2031. Sadly we first crossed this level in April 2021, 10 years earlier than our projection.  This is a very concerning trend.

To quantify the model projection errors/biases, we calculated the RMSE of the models.  Among the three models, the ARIMA model has the lowest RSME (8.2), in comparison to the linear model (14.1) and the polynomial model (17.6).


```{r, cross-420-ppm}
co2_present %>%
  dplyr::filter(value >= 420) %>%
  head(1)
```

```{r, generate-prediction-resid, echo=FALSE, message=FALSE, warning=FALSE}
resid <- prediction_ts %>%
  mutate(
    lm_resid = value - lm_forecast,
    poly_resid = value - poly_forecast,
    arima_resid = value - arima_forecast
  ) %>%
  select(month_index, lm_resid, poly_resid, arima_resid)

# filter the last value for RMSE, display the RMSE in ggplot
resid_last <- resid %>%
  filter(month_index == max(month_index)) %>%
  mutate(
    lm_resid = lm_resid + 0.5,
    poly_resid = poly_resid + 0.5,
    arima_resid = arima_resid + 1
  ) %>%
  add_column(
    lm_rmse = round(sqrt(mean(resid$lm_resid^2)), 1),
    poly_rmse = round(sqrt(mean(resid$poly_resid^2)), 1),
    arima_rmse = round(sqrt(mean(resid$arima_resid^2)), 1)
  )

resid %>%
  ggplot() +
  geom_line(aes(x = month_index, y = lm_resid, color = "Linear")) +
  geom_text(aes(x = month_index, y = lm_resid, label = paste("RMSE:", lm_rmse)), data = resid_last) +
  geom_line(aes(x = month_index, y = poly_resid, color = "Polynomial")) +
  geom_text(aes(x = month_index, y = poly_resid, label = paste("RMSE:", poly_rmse)), data = resid_last) +
  geom_line(aes(x = month_index, y = arima_resid, color = "ARIMA")) +
  geom_text(aes(x = month_index, y = arima_resid, label = paste("RMSE:", arima_rmse)), data = resid_last) +
  labs(
    x = "Month and Year",
    y = "CO2 Level (ppm)",
    title = "Model Prediction Biases"
  )
```

```{r, formal-test-Ljung-Box, include = FALSE, echo=FALSE, message=FALSE, warning=FALSE}
# use Ljung-Box test to gauge residual stationarity

# Linear model residual
resid %>%
  select(lm_resid) %>%
  as.ts() %>%
  Box.test(lag = 10, type = "Ljung-Box")


# Polynomial model residual
resid %>%
  select(poly_resid) %>%
  as.ts() %>%
  Box.test(lag = 10, type = "Ljung-Box")

# resid %>%
#   model(stl = STL(poly_resid)) %>%
#   components() %>%
#   autoplot()

# ARIMA model residual
resid %>%
  select(arima_resid) %>%
  as.ts() %>%
  Box.test(lag = 10, type = "Ljung-Box")

# resid %>%
#   model(stl = STL(arima_resid)) %>%
#   components() %>%
#   autoplot()
```


## (4 points) Task 5b: Train best models on present data

As noted above, the 1997 ARIMA model yielded the best prediction results, even though it still underestimated the actuals, especially after 2005. We decided to refit the ARIMA model using the actual data. 

For both SA and NSA series, the present co2 dataset shows some similar characteristics to the 1997 co2 dataset. In our 1997 ARIMA model fit process, we used BIC as the goodness-of-fit assessment criteria to choose the optimal model version.  We believe this approach is still appropriate for refitting the ARIMA model using the present data series. We will choose the best ARIMA models with the lowest BIC score.

```{r seasonality-adjusted}
dcmp_components <- dcmp_add %>% components()
co2_enhanced <- co2_enhanced %>%
  mutate(seasonal_adj_value = dcmp_components$season_adjust,
         seasonal_value = dcmp_components$season_year)

# plot the annualized growth rate
p_norm <- co2_enhanced %>%
  ggplot() +
  aes(x = time_index, y = value) +
  geom_line(color = "steelblue") +
  labs(
    title = TeX("Atmospheric CO2 Level"),
    subtitle = 'The "Keeling Curve"',
    x = "Month and Year",
    y = TeX(r'($CO_2$ Level)')
  ) +
  theme(plot.title = element_text(size = 10))

p_seasonal_adj <- co2_enhanced %>%
  ggplot() +
  aes(x = time_index, y = seasonal_adj_value) +
  geom_line(color = "steelblue") +
  labs(
    title = TeX("Seasonality Adjusted Atmospheric CO2 Level"),
    subtitle = 'The "Keeling Curve"',
    x = "Month and Year",
    y = TeX(r'($CO_2$ Level)')
  ) +
  theme(plot.title = element_text(size = 10))

p_norm | p_seasonal_adj
```

```{r train-test-split}
co2_train <- co2_enhanced %>%
  filter(year < 2020)
co2_test <- co2_enhanced %>%
  filter(year >= 2020)
```

```{r estimating-weekly-arima-model}
co2.weekly.arima.nsa <- co2_train %>%
  model(nsa_arima = ARIMA(value, ic = "bic"))

co2.weekly.arima.nsa %>% report()
```

> ARIMA(0,1,2)(2,1,0)[52] 

```{r visualzied-fitted-models}
co2.weekly.arima.sa <- co2_train %>%
  model(sa_arima = ARIMA(
    seasonal_adj_value ~ 1 + pdq(0:10, 1, 0:10) + PDQ(0, 0, 0), ic = "bic", stepwise = F, greedy = F))

co2.weekly.arima.sa %>% report()
```

> Since the searies is sesonally adjusted, we estimated this to be ARIMA(2,1,3)


```{r polynomial-sa-fit}
fit_cubic_season <- co2_train %>%
  model(trend_model = TSLM(seasonal_adj_value ~ trend() + I(trend()^2) + I(trend()^3) + season()))
#fit_cubic_season %>% report()
```

> Using same fit as before

```{r in-sample-fit}
# extract fitted values and merge fitted values together
nsa.fitted <- co2.weekly.arima.nsa %>% fitted.values()
sa.fitted <- co2.weekly.arima.sa %>% fitted.values()

fitted_values <- nsa.fitted %>% left_join(sa.fitted, by = "time_index", suffix = c("_nsa", "_sa"))
in_sample_df <- co2_train %>% left_join(fitted_values, by = "time_index")


p_insample_nsa <- in_sample_df %>%
  ggplot(aes(x = time_index)) +
  geom_line(aes(y = value, colour = "Data")) +
  geom_line(aes(y = .fitted_nsa, colour = "Fitted")) +
  labs(
    y = "CO2 Level",
    title = "In-Sample 
    Non-Seaonal Adjusted 
    ARIMA Model"
  )

p_insample_sa <- in_sample_df %>%
  ggplot(aes(x = time_index)) +
  geom_line(aes(y = seasonal_adj_value, colour = "Data")) +
  geom_line(aes(y = .fitted_sa, colour = "Fitted")) +
  labs(
    y = "CO2 Level",
    title = "In-Sample 
    Seaonal Adjusted 
    ARIMA Model"
  )


p_insample_poly <- augment(fit_cubic_season) %>%
  ggplot(aes(x = time_index)) +
  geom_line(aes(y = seasonal_adj_value, colour = "Data")) +
  geom_line(aes(y = .fitted, colour = "Fitted")) +
  labs(
    y = "CO2 Level",
    title = "In-Sample 
    Seasonality Adjusted 
    3rd Degree Polynomial"
  )

(p_insample_nsa / p_insample_sa) | p_insample_poly
```

```{r out-of-sample-forecast}
arima.nsa.forecast <- co2.weekly.arima.nsa %>%
  forecast(h = nrow(co2_test), level = c(95)) %>%
  autoplot(co2_test, color = "red") +
  labs(
    x = "Week",
    y = "CO2 Level",
    title = "Out-Of-Sample 
    Non-Seaonal Adjusted 
    ARIMA Model"
  )

arima.sa.forecast <- co2.weekly.arima.sa %>%
  forecast(h = nrow(co2_test), level = c(95)) %>%
  autoplot(co2_test, color = "red") +
  labs(
    x = "Week",
    y = "CO2 Level",
    title = "Out-Of-Sample 
    Seaonally Adjusted 
    ARIMA Model"
  )

polynomial.sa.forecast <- fit_cubic_season %>%
  forecast(h = nrow(co2_test), level = c(95)) %>%
  autoplot(co2_test, color = "red") +
  labs(
    x = "Week",
    y = "CO2 Level",
    title = "Out-Of-Sample 
    Seaonally Adjusted 
    Polynomial Model"
  )

(arima.nsa.forecast / arima.sa.forecast) | polynomial.sa.forecast
```
```{r compute-rmse}
arima.nsa.forecast <- co2.weekly.arima.nsa %>%
  forecast(h = nrow(co2_test), level = c(95))

arima.sa.forecast <- co2.weekly.arima.sa %>%
  forecast(h = nrow(co2_test), level = c(95))

polynomial.sa.forecast <- fit_cubic_season %>%
  forecast(h = nrow(co2_test), level = c(95))


arima_nsa_rmse <- round(sqrt(mean((co2_test$value - arima.nsa.forecast$.mean)^2)),3)
arima_sa_rmse <-  round(sqrt(mean((co2_test$seasonal_adj_value - arima.sa.forecast$.mean)^2)),3)
poly_sa_rmse <-  round(sqrt(mean((co2_test$seasonal_adj_value - polynomial.sa.forecast$.mean)^2)),3)


RMSE <- data.frame(arima_nsa_resid = arima_nsa_rmse,
                    arima_sa_resid = arima_sa_rmse,
                    poly_sa_resid = poly_sa_rmse)

RMSE
```
## (3 points) Task Part 6b: How bad could it get?

With the non-seasonally adjusted data series, generate predictions for when atmospheric CO2 is expected to be at 420 ppm and 500 ppm levels for the first and final times (consider prediction intervals as well as point estimates in your answer). Generate a prediction for atmospheric CO2 levels in the year 2122. How confident are you that these will be accurate predictions?


```{r ARIMA-distant-future-forecast, echo=FALSE, message=FALSE, warning=FALSE, fig.align='center', out.width="65%", fig.cap="Non-Seasonally Adjusted ARIMA forward forecast model"}
arima_pred <- co2.weekly.arima.nsa %>% forecast(h = 122 * 52, level = c(95))

arima_pred %>%
  autoplot(co2_train) +
  geom_hline(yintercept = 420, color = "red") +
  geom_hline(yintercept = 500, color = "red") +
  labs(
    x = "Week",
    y = "CO2 Level",
    title = "Forward Forcast Non-Seaonal Adjusted ARIMA Model"
  )
```

```{r arima-forecast-ci, echo=FALSE, message=FALSE, warning=FALSE}
lower <- data.frame(arima_pred) %>%
  filter(.mean >= 420) %>%
  head(1)

upper <- data.frame(arima_pred) %>%
  filter(.mean <= 500) %>%
  tail(1)

level2122 <- data.frame(arima_pred) %>%
  filter(year(time_index) == 2122) %>%
  head(1)


co2_bounds <- dplyr::bind_rows(lower, upper, level2122)
co2_bounds %>% select(time_index, .mean)
```

> CO2 level will reach 420 by 18th week of 2021, 500 by 34th week of 2056
> CO2 level will be 668 by 2122

-------------------------


```{r ETSDA normal series}
# ETSDA
# plot the series
series <- co2_train %>%
  ggplot(aes(x = time_index, y = seasonal_adj_value)) +
  geom_line() +
  ggtitle("Atmospheric CO2 Time Series") +
  xlab("Date") +
  ylab("CO2 level ppm")

# plot of histogram
histogram <- co2_train %>%
  ggplot(aes(x = seasonal_adj_value)) +
  geom_histogram(color = "black", fill = "white", binswidth = 10) +
  ggtitle("Atmospheric CO2 Histogram") +
  xlab("CO2 level ppm")


# plot acf and pacf
acf <- ggAcf(co2_train$seasonal_adj_value, level = 0.95)
pacf <- ggPacf(co2_train$seasonal_adj_value, level = 0.95)

(series | histogram) /
  (acf | pacf)
```


```{r ETSDA seasonality adj series}
# ETSDA
# plot the series
series <- co2_train %>%
  ggplot(aes(x = time_index, y = value)) +
  geom_line() +
  ggtitle("Atmospheric CO2 Time Series") +
  xlab("Date") +
  ylab("CO2 level ppm")

# plot of histogram
histogram <- co2_train %>%
  ggplot(aes(x = value)) +
  geom_histogram(color = "black", fill = "white", binswidth = 10) +
  ggtitle("Atmospheric CO2 Histogram") +
  xlab("CO2 level ppm")


# plot acf and pacf
acf <- ggAcf(co2_train$value, level = 0.95)
pacf <- ggPacf(co2_train$value, level = 0.95)

(series | histogram) /
  (acf | pacf)
```

```{r first order diff ETSDA plot}
# plot the series
co2_present$diff <- c(0, diff(co2_present$value))

series <- co2_present %>%
  ggplot(aes(x = time_index, y = diff)) +
  geom_line() +
  ggtitle("CO2 1st Order Difference Time Series") +
  xlab("Date") +
  ylab("CO2 (ppm)")

# plot of histogram
histogram <- co2_present %>%
  ggplot(aes(x = diff)) +
  geom_histogram(color = "black", fill = "white", binwidth = 10) +
  ggtitle("CO2 1st Order Difference Histogram") +
  xlab("CO2 (ppm)")


# plot acf and pacf
acf <- ggAcf(co2_present$diff, ci = 0.95)
pacf <- ggPacf(co2_present$diff, ci = 0.95)

(series | histogram) /
  (acf | pacf)
```
> looks like white noise ...


