---
title: 'W271 Lab 2: CO2 Present'
geometry: margin=1in
output:
  github_document: default
---

```{r load packages, echo = FALSE, message = FALSE}
library(tidyverse)
library(tsibble)
library(latex2exp)
theme_set(theme_minimal())
knitr::opts_chunk$set(dpi = 1000)
knitr::opts_chunk$set(tidy.opts = list(width_cutoff = 100), tidy = TRUE)
knitr::opts_chunk$set(message = FALSE)

# additional packages
library(dplyr)
library(Hmisc)
library(patchwork)
library(forecast)
library(stargazer)
library(gridExtra)
library(magrittr)

## To laod All data sets in the book "Forecasting: principles and practice"
# by Rob J Hyndman and George Athanasopoulos
# install.packages("fpp3")
# install.packages("fpp2")

library(fpp3)
library(fpp2)
```

## (3 points) Task 0b: Introduction 
Following up on the 1997 publication on the study on the time-dependent atmospheric $CO_2$ build up. Since then, atmospheric $CO_2$ has increases from 360 to 420 ppm. 

We are re-evaluating the models and forecasts from the 1997 paper, in an attempt to understand the current state of the atmosphere and the future of $CO_2$ levels.

## (3 points) Task 1b: Create a modern data pipeline for Mona Loa CO2 data.

```{r data-load-pipeline-from-website}
co2_present_raw <- read.csv("https://gml.noaa.gov/webdata/ccgg/trends/co2/co2_weekly_mlo.csv",
  sep = ",",
  skip = 51
)
head(co2_present_raw)
```

```{r create-time-component}
co2_present_raw <- co2_present_raw %>%
  select(year, month, day, average) %>%
  mutate(time_index = yearweek(
    paste(
      year,
      month,
      day,
      sep = "-"
    )
  ))

co2_present_raw %>%
  ggplot(aes(y = average, x = time_index)) +
  geom_line()
```

```{r eda: fill-the-missing-weekly-data-from-monthly}
co2_present_month <- read.csv(
  "https://gml.noaa.gov/webdata/ccgg/trends/co2/co2_mm_mlo.csv",
  sep = ",", skip = 56
)

# remove outliers and replace with monthly average
co2_present_raw <- co2_present_raw %>%
  left_join(y = co2_present_month, by = c("year", "month")) %>%
  within(., value <- ifelse(average.x == -999.99, average.y, average.x))

co2_present <- co2_present_raw %>%
  dplyr::select(time_index, year, month, day, value) %>%
  tsibble::as_tsibble(index = time_index)

# basic information about the data
# head(co2_present)
# print(sum(is.na(co2_present)))
# print(start(co2_present$time_index))
# print(end(co2_present$time_index))
```


```{r time-plot}
co2_present %>%
  ggplot() +
  aes(x = time_index, y = value) +
  geom_line(color = "steelblue") +
  labs(
    title = TeX(r'(Present Date Monthly Mean $CO_2$)'),
    subtitle = 'The "Keeling Curve"',
    x = "Month and Year",
    y = TeX(r'($CO_2$ parts per million)')
  )
```

```{r CO2-ETSDA, echo = FALSE, warning=FALSE, message=FALSE, fig.align='center', out.width="65%", fig.cap="Atmospheric CO2 Level Time Series Overview"}
co2_enhanced <- co2_present %>%
  mutate(
    annual_growth = (value - lag(value, n = 52)) / lag(value, n = 52) * 100,
    log_value = log(value)
  )

# Use additive method in STL decomposition
dcmp_add <- co2_enhanced %>%
  model(stl = STL(value))

# plot of time series
p1 <- components(dcmp_add) %>%
  as_tsibble() %>%
  autoplot(value, colour = "gray") +
  geom_line(aes(y = trend), colour = "#D55E00") +
  labs(
    y = TeX(r"($CO_2$ Annualized Growth Rate)"),
    x = "Month and Year",
    title = "Monthly Mean CO2"
  ) +
  theme(plot.title = element_text(size = 10))

# plot the annualized growth rate
p2 <- co2_enhanced %>%
  ggplot() +
  aes(x = time_index, y = annual_growth) +
  geom_line(color = "steelblue") +
  labs(
    title = TeX(r'(Annualized Growth $CO_2$)'),
    subtitle = 'The "Keeling Curve"',
    x = "Month and Year",
    y = TeX(r'($CO_2$ Annualized Growth Rate)')
  ) +
  theme(plot.title = element_text(size = 10))

# plot the histogram
p3 <- co2_enhanced %>%
  ggplot(aes(x = value)) +
  geom_histogram(binwidth = 1) +
  labs(title = TeX(r'(Histogram Monthly Mean $CO_2$)'), col = " blue") +
  xlab("Monthly Mean") +
  theme(plot.title = element_text(size = 10))
# scale_x_continuous(limits = c(0, 16), breaks = seq(1,16,2))

# plot the components
p4 <- components(dcmp_add) %>%
  autoplot() + theme(plot.title = element_text(size = 10))

(p1 | p2) / (p3 | p4)
```

To be able to compare the observed weekly data with model forecasts, which were done using monthly series, we aggregated the weekly data to monthly data by taking all average for all the weeks in a month.

```{r generate-monthly-indexed-summary}
co2_present_monthly <- co2_present %>%
  index_by(month_index = ~ yearmonth(.)) %>%
  summarise(
    value = mean(value)
  ) %>%
  tsibble::as_tsibble(index = month_index) %>%
  drop_na()
```

```{r boxplot, echo=FALSE, echo=FALSE, message=FALSE, warning=FALSE, fig.align='center', out.width="65%", fig.cap="Seasonality CO2 Level Monthly Distribution"}
# box plot
co2_present_ts <- co2_present_monthly %>%
  select(month_index, value) %>%
  as.ts()

box <- boxplot(co2_present_ts ~ cycle(co2_present_ts, xlab = "Month", ylab = "CO2 (ppm)", main = "Monthly Mean CO2"))
```
> The boxplot is shifted by a month, which could indicate a systematic change?

## (1 point) Task 2b: Compare linear model forecasts against realized CO2

Descriptively compare realized atmospheric CO2 levels to those predicted by your forecast from a linear time model in 1997 (i.e. “Task 2a”). (You do not need to run any formal tests for this task.)

```{r, original-linear-model}
# create a time series for the prediction period
co2_cutoff <- yearmonth(lubridate::make_date(1998, 1))
prediction_ts <- co2_present_monthly %>%
  filter(month_index >= co2_cutoff)
h <- length(prediction_ts$month_index)

# original linear model with forecast
mod.poly <- tslm(co2 ~ poly(trend, 3) + season)
poly_forecast <- forecast::forecast(mod.poly, level = c(95), h = h)

mod.lm <- tslm(co2 ~ trend)
lm_forecast <- forecast::forecast(mod.lm, level = c(95), h = h)

prediction_ts <- prediction_ts %>%
  add_column(
    poly_forecast = poly_forecast$mean
  ) %>%
  add_column(
    lm_forecast = lm_forecast$mean
  )

# visualize the forecast vs the actual
prediction_ts %>%
  ggplot() +
  aes(x = month_index) +
  geom_line(aes(x = month_index, y = value, color = "Actual")) +
  geom_line(aes(x = month_index, y = lm_forecast, color = "Linear")) +
  geom_line(aes(x = month_index, y = poly_forecast, color = "Polynomial")) +
  labs(
    x = "Month and Year",
    y = "CO2 Level (ppm)",
    title = "Model Prediction vs Actual CO2 Level"
  )
```

## (1 point) Task 3b: Compare ARIMA models forecasts against realized CO2  


Descriptively compare realized atmospheric CO2 levels to those predicted by your forecast from the ARIMA model that you fitted in 1997 (i.e. "Task 3a"). Describe how the Keeling Curve evolved from 1997 to the present.

```{r, original-arima-model}
# original arima model with forecast
mod.arima <- arima(co2, order = c(0, 1, 1), seasonal = list(order = c(1, 1, 2), period = 12))
arima_forecast <- forecast::forecast(mod.arima, level = c(95), h = h)

prediction_ts <- prediction_ts %>% add_column(
  arima_forecast = arima_forecast$mean
)

# visualize the forecast vs the actual
prediction_ts %>%
  ggplot() +
  geom_line(aes(x = month_index, y = value, color = "Actual")) +
  geom_line(aes(x = month_index, y = poly_forecast, color = "Polynomial")) +
  geom_line(aes(x = month_index, y = arima_forecast, color = "ARIMA")) +
  labs(
    x = "Month and Year",
    y = "CO2 Level (ppm)",
    title = "Model Prediction vs Actual CO2 Level"
  )
```

## (3 points) Task 4b: Evaluate the performance of 1997 linear and ARIMA models 

In 1997 you made predictions about the first time that CO2 would cross 420 ppm. How close were your models to the truth? 

After reflecting on your performance on this threshold-prediction task, continue to use the weekly data to generate a month-average series from 1997 to the present, and compare the overall forecasting performance of your models from Parts 2a and 3b over the entire period. (You should conduct formal tests for this task.) 

```{r, cross-420-ppm}
co2_present %>%
  dplyr::filter(value >= 420) %>%
  head(1)
```

$CO_2$ crossed 420 ppm in the last week of April 2021. This is 10 years faster than the prediction made by the linear model in 1997. The ARIMA model predicted that $CO_2$ would cross 420 ppm by May 2031.

```{r, generate-prediction-resid}
resid <- prediction_ts %>%
  mutate(
    poly_resid = value - poly_forecast,
    arima_resid = value - arima_forecast
  ) %>%
  select(month_index, poly_resid, arima_resid)

# filter the last value for RMSE, display the RMSE in ggplot
resid_last <- resid %>%
  filter(month_index == max(month_index)) %>%
  mutate(
    poly_resid = poly_resid + 0.5,
    arima_resid = arima_resid + 1
  ) %>%
  add_column(
    poly_rmse = round(sqrt(mean(resid$poly_resid^2)), 1),
    arima_rmse = round(sqrt(mean(resid$arima_resid^2)), 1)
  )

resid %>%
  ggplot() +
  geom_line(aes(x = month_index, y = poly_resid, color = "Polynomial")) +
  geom_text(aes(x = month_index, y = poly_resid, label = paste("RMSE:", poly_rmse)), data = resid_last) +
  geom_line(aes(x = month_index, y = arima_resid, color = "ARIMA")) +
  geom_text(aes(x = month_index, y = arima_resid, label = paste("RMSE:", arima_rmse)), data = resid_last) +
  labs(
    x = "Month and Year",
    y = "CO2 Level (ppm)",
    title = "Model Prediction Biases"
  )
```

```{r, formal-test-Ljung-Box}
# use Ljung-Box test to gauge residual stationarity

# Polynomial model residual
resid %>%
  select(poly_resid) %>%
  as.ts() %>%
  Box.test(lag = 10, type = "Ljung-Box")

resid %>%
  model(stl = STL(poly_resid)) %>%
  components() %>%
  autoplot()

# ARIMA model residual
resid %>%
  select(arima_resid) %>%
  as.ts() %>%
  Box.test(lag = 10, type = "Ljung-Box")

resid %>%
  model(stl = STL(arima_resid)) %>%
  components() %>%
  autoplot()
```


## (4 points) Task 5b: Train best models on present data

Seasonally adjust the weekly NOAA data, and split both seasonally-adjusted (SA) and non-seasonally-adjusted (NSA) series into training and test sets, using the last two years of observations as the test sets. For both SA and NSA series, fit ARIMA models using all appropriate steps. Measure and discuss how your models perform in-sample and (psuedo-) out-of-sample, comparing candidate models and explaining your choice. In addition, fit a polynomial time-trend model to the seasonally-adjusted series and compare its performance to that of your ARIMA model.

```{r seasonality-adjusted}
dcmp_components <- dcmp_add %>% components() 
co2_enhanced <- co2_enhanced %>%
                mutate(seasonal_adj_value = dcmp_components$season_adjust)

# plot the annualized growth rate
p_norm <- co2_enhanced %>%
  ggplot() +
  aes(x = time_index, y = value) +
  geom_line(color = "steelblue") +
  labs(
    title = TeX('Atmospheric CO2 Level'),
    subtitle = 'The "Keeling Curve"',
    x = "Month and Year",
    y = TeX(r'($CO_2$ Level)')
  ) +
  theme(plot.title = element_text(size = 10))

p_seasonal_adj <- co2_enhanced %>%
  ggplot() +
  aes(x = time_index, y = seasonal_adj_value) +
  geom_line(color = "steelblue") +
  labs(
    title = TeX('Seasonality Adjusted Atmospheric CO2 Level'),
    subtitle = 'The "Keeling Curve"',
    x = "Month and Year",
    y = TeX(r'($CO_2$ Level)')
  ) +
  theme(plot.title = element_text(size = 10))

p_norm | p_seasonal_adj
```

```{r train-test-split}
co2_train <- co2_enhanced %>%
        filter(year < 2020)
co2_test <- co2_enhanced %>%
        filter(year >= 2020)
co2_train
```

```{r estimating-weekly-arima-model}
# NSA model
# Have R optimze the best model based on AICc for the seasonal model\
co2.weekly.arima.nsa <- co2_train %>% 
                  model(nsa_arima = ARIMA(value, ic = 'aicc'))


co2.weekly.arima.nsa %>% report()
```

> ARIMA(0,1,2)(2,1,0)[52] 

```{r visualzied-fitted-models}
co2.weekly.arima.sa <- co2_train %>% 
                  model(sa_arima = ARIMA(seasonal_adj_value ~ 1
                                      + pdq(0:10, 1, 0:10)
                                      + PDQ(0, 0, 0),
                                      ic = 'aicc',
                                      stepwise=F,
                                      greedy=F))

co2.weekly.arima.sa %>% report()
```

> Since the searies is sesonally adjusted, westimated this to be ARIMA(2,1,3)


```{r polynomial-sa-fit}
fit_quadratic_season <- co2_train %>%
  model(trend_model = TSLM(seasonal_adj_value ~ trend() 
                                              + I(trend()^2) 
                                              + I(trend()^3) 
                                              + season()))
fit_quadratic_season %>% report()
```

```{r in-sample-fit}
# extract fitted values and merge fitted values together
nsa.fitted <- co2.weekly.arima.nsa %>% fitted.values()
sa.fitted <- co2.weekly.arima.sa %>% fitted.values()

fitted_values <- nsa.fitted %>% left_join(sa.fitted, by="time_index", suffix=c("_nsa", "_sa"))
in_sample_df <- co2_train %>% left_join(fitted_values, by="time_index")


p_insample_nsa <- in_sample_df %>%
  ggplot(aes(x = time_index)) +
  geom_line(aes(y = value, colour = "Data")) +
  geom_line(aes(y = .fitted_nsa, colour = "Fitted")) +
  labs(y = "Time",
       title = "In-Sample Non-Seaonal Adjusted ARIMA Model")

p_insample_sa <- in_sample_df %>%
  ggplot(aes(x = time_index)) +
  geom_line(aes(y = seasonal_adj_value, colour = "Data")) +
  geom_line(aes(y = .fitted_sa, colour = "Fitted")) +
  labs(y = "Time",
       title = "In-Sample Seaonal Adjusted ARIMA Model")


p_insample_poly <- augment(fit_quadratic_season)%>%
  ggplot(aes(x = time_index)) +
  geom_line(aes(y = seasonal_adj_value, colour = "Data")) +
  geom_line(aes(y = .fitted, colour = "Fitted")) +
  labs(y = "Time",
       title = "In-Sample Seasonality Adjusted 3rd Degree Polynomial")

p_insample_nsa / p_insample_sa / p_insample_poly
```

```{r out-of-sample-forecast}
# TODO (after gym break)
```

-------------------------
```{r ETSDA normal series}
# ETSDA
# plot the series
series <- co2_train %>%
            ggplot(aes(x = time_index, y = seasonal_adj_value)) +
            geom_line() +
            ggtitle("Atmospheric CO2 Time Series") +
            xlab("Date") +
            ylab("CO2 level ppm")

# plot of histogram
histogram <- co2_train %>% 
            ggplot(aes(x=seasonal_adj_value)) +
            geom_histogram(color="black", fill="white", binswidth=10) +
            ggtitle("Atmospheric CO2 Histogram") +
            xlab("CO2 level ppm")


# plot acf and pacf
acf <- ggAcf(co2_train$seasonal_adj_value, level=0.95)
pacf <- ggPacf(co2_train$seasonal_adj_value, level=0.95)

(series | histogram) /
(acf | pacf)
```


```{r ETSDA seasonality adj series}
# ETSDA
# plot the series
series <- co2_train %>%
            ggplot(aes(x = time_index, y = value)) +
            geom_line() +
            ggtitle("Atmospheric CO2 Time Series") +
            xlab("Date") +
            ylab("CO2 level ppm")

# plot of histogram
histogram <- co2_train %>% 
            ggplot(aes(x=value)) +
            geom_histogram(color="black", fill="white", binswidth=10) +
            ggtitle("Atmospheric CO2 Histogram") +
            xlab("CO2 level ppm")


# plot acf and pacf
acf <- ggAcf(co2_train$value, level=0.95)
pacf <- ggPacf(co2_train$value, level=0.95)

(series | histogram) /
(acf | pacf)
```

```{r first order diff ETSDA plot}
# plot the series
co2_present$diff <- c(0, diff(co2_present$value))

series <- co2_present %>%
  ggplot(aes(x = time_index, y = diff)) +
  geom_line() +
  ggtitle("CO2 1st Order Difference Time Series") +
  xlab("Date") +
  ylab("CO2 (ppm)")

# plot of histogram
histogram <- co2_present %>%
  ggplot(aes(x = diff)) +
  geom_histogram(color = "black", fill = "white", binwidth = 10) +
  ggtitle("CO2 1st Order Difference Histogram") +
  xlab("CO2 (ppm)")


# plot acf and pacf
acf <- ggAcf(co2_present$diff, ci = 0.95)
pacf <- ggPacf(co2_present$diff, ci = 0.95)

(series | histogram) /
  (acf | pacf)
```
> looks like white noise ...



## (3 points) Task Part 6b: How bad could it get?

With the non-seasonally adjusted data series, generate predictions for when atmospheric CO2 is expected to be at 420 ppm and 500 ppm levels for the first and final times (consider prediction intervals as well as point estimates in your answer). Generate a prediction for atmospheric CO2 levels in the year 2122. How confident are you that these will be accurate predictions?
